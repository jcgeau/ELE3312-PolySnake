/**
  * @file DACSound.cpp
  * @date June 2025
  * @brief this file contains implementation of the DACSound class that implements 
  * the Sound interface for the PacMan game.
  * 
  * @defgroup ELE3312
  * @{
  */

#include "NucleoImp/Sound/DACSound.h"
#include <cstdint>
#include <cmath>

namespace ELE3312 {

#ifdef __cplusplus
extern "C" {
#endif
void HAL_DAC_ConvCpltCallbackCh1(DAC_HandleTypeDef* hdac) {
	DACSound::dacCpltEvent = 1;
}
#ifdef __cplusplus
}
#endif

volatile uint16_t DACSound::dacCpltEvent = 0;

/** @brief Setup routine for the DACSound class.
  * @param [in] hdac Pointer to the DAC periphery handler used to generate an analog signal (sound).
  * @param [in] thim Pointer to the Timer periphery.
  * @param [in] baseFreq The frequency of the micro controller used to determine the sampling frequency.
  */
void DACSound::setup(DAC_HandleTypeDef *hdac, TIM_HandleTypeDef *htim, uint64_t baseFreq){
	// Determine the sampling frequency
	this->hdac = hdac;
	this->htim = htim;
	this->baseFreq = baseFreq;
	sampleFrequency = (baseFreq/(htim->Instance->PSC + 1))/htim->Instance->ARR;
	waveform = Waveform::Sinus;
	generateWaveLUT(sampleBuffer1, &sampleBuffer1Length);
	HAL_TIM_Base_Start(htim);
}

/** @brief Constructor for the DACSound class.
  */
DACSound::DACSound() {
	soundEnabled = false;
}

/** @brief Enables the sound.
  */
void DACSound::enableSound() {
	HAL_DAC_Start_DMA(hdac, DAC_CHANNEL_1, currentBuffer, *sampleBufferLength, DAC_ALIGN_12B_R);
	soundEnabled = true;

}

/** @brief Disables the sound.
  */
void DACSound::disableSound(){
	HAL_DAC_Stop_DMA(hdac, DAC_CHANNEL_1);
	soundEnabled = false;
}

/** @brief Sets the frequency of the produced sound.
  * @param [in] freq A floating point value of the frequency generated when the sound is enabled.
  */
void DACSound::setFrequency(float freq){
	currentFrequency = freq;
	int status = 0;
	if (currentBuffer != sampleBuffer1){
		status = generateWaveLUT(sampleBuffer1, &sampleBuffer1Length); // Update wave look up table
	} else {
		status = generateWaveLUT(sampleBuffer2, &sampleBuffer2Length);
	}
	if (status == 0){
		needUpdate = true;
	}
}

/** @brief Sets the musical note that is going to be played when the sound is enabled.
  * @param [in] note The musical note to play.
  */
void DACSound::setNote(const Note &note){
	currentNote = note;
	setFrequency(currentNote.getFrequency());
}

/** @brief Function that populates the look up table (LUT) used to generat the desired 
  * waveform.
  * @param [out] buffer The buffer into which the LUT is written.
  * @param [in] bufferLength The size of the specified output buffer.
  * @retval 0 Indicates that the buffer was successfully written.
  * @retval -1 Indicates that there was an error.
  */
int DACSound::generateWaveLUT(uint32_t *buffer, uint32_t *bufferLength){
	// Get duration of a single data point
	float period = 1/currentFrequency;
	uint32_t numSamplesPP = period * sampleFrequency;
	if (numSamplesPP > sampleBufferSize){
		return -1;
	}
	float radIncrement = 2 * pi / numSamplesPP;
	uint32_t numPeriodsInBuffer = sampleBufferSize / numSamplesPP;
	*bufferLength = numPeriodsInBuffer * numSamplesPP;
	// Fill the buffer with samples of the sine wave
	for(uint32_t i = 0; i<*bufferLength; ++i){
		switch(waveform) {
			case Waveform::Sinus:
				buffer[i] = (sin((i%numSamplesPP)*radIncrement) + 1)*(2025 * amplitude)/100;
				break;
			case Waveform::Square:
				buffer[i] = (i % numSamplesPP) < (numSamplesPP/2) ? (4000 * amplitude)/100 : 0;
				break;
		}
	}
	return 0;
}

/** @brief Method that updates the current sound generated by the DAC.
  */
void DACSound::update(){
	if (needUpdate && soundEnabled){
		// Wait for the DAC to finish the buffer so that we change the buffer when the signal is
		// zero or at least close to zero
		dacCpltEvent = 0;
		while(dacCpltEvent == 0); // Add timeout
		disableSound();
		if(currentBuffer == sampleBuffer1) {
			currentBuffer = sampleBuffer2;
			sampleBufferLength = &sampleBuffer2Length;
		} else {
			currentBuffer = sampleBuffer1;
			sampleBufferLength = &sampleBuffer1Length;
		}
		needUpdate = false;
		enableSound();
	}
}


/** @brief Sets the amplitude of the generated sound wave.
  * @param value The amplitude value.
  */
void DACSound::setAmplitude(uint16_t value) {
	setFrequency(currentNote.getFrequency());
	amplitude = value <= 100 ? value : 100;
}

/** @brief Returns the amplitude value (in percent) of the generated wave.
  * @retval The amplitude value of the wave.
  */
uint16_t DACSound::getAmplitude() const {
	return amplitude;
}

} /* namespace ELE3312 */

/**
  * @}
  */ // End of documentation group ELE3312
